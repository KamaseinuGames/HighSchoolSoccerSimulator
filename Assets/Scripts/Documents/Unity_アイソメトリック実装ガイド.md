# Unity アイソメトリック（斜め視点2D）実装ガイド

## アイソメトリックとは？

2Dだけど斜め上から見下ろしたような視点。Coffee Inc、シムシティ、ファイアーエムブレムなどで採用。

```
【通常のトップダウン2D】          【アイソメトリック2D】

    ┌────────┐                        ◇
    │        │                      ◇   ◇
    │   □   │                    ◇   □   ◇
    │        │                      ◇   ◇
    └────────┘                        ◇
      ↑正方形                        ↑ひし形に見える
```

---

## 実装方法 3パターン

### 1. 2Dスプライト方式（最もシンプル）

```
カメラ:    Orthographic（正射影）
スプライト: 斜め上視点で描いた絵を使用
ソート:    Y座標で描画順を制御
```

| メリット | デメリット |
|----------|------------|
| 軽量・シンプル | 素材を全部斜め視点で描く必要あり |
| 2D知識だけで作れる | 回転・角度変更が難しい |

---

### 2. 3Dモデル + Orthographicカメラ方式

```
カメラ:    Orthographic
カメラ角度: X=30〜45°, Y=45° に傾ける
モデル:    ローポリ or セルシェーダーで2D風に
```

| メリット | デメリット |
|----------|------------|
| 回転・アニメーションが楽 | 3Dモデル制作が必要 |
| 視点変更も可能 | 若干重くなる |

---

### 3. Unity Isometric Tilemap（公式機能）

Unity 2018.3以降で標準搭載。タイルベースのゲームに最適。

```
設定手順:
1. Hierarchy → 2D Object → Tilemap → Isometric
2. Grid の Cell Layout を「Isometric」に設定
3. タイルを配置すれば自動でアイソメ配置
```

| メリット | デメリット |
|----------|------------|
| 公式サポート・安定 | タイル以外の自由配置に工夫が必要 |
| タイルマップ向き | 自由なレイアウトには不向き |

---

## 当たり判定の問題と解決策

### 問題: スプライトは四角、見た目はひし形

```
┌────────────┐
│    ◇◇    │ ← 透明な余白（四隅）
│  ◇◇◇◇  │
│ ◇◇◇◇◇◇ │ ← 実際の絵（ひし形）
│  ◇◇◇◇  │
│    ◇◇    │
└────────────┘
↑ スプライトのバウンディングボックスは四角
```

### 解決策

| 方法 | 説明 | 適したケース |
|------|------|--------------|
| **Box Collider 2D** | 四角い当たり判定 | 大雑把でOKなゲーム |
| **Polygon Collider 2D** | ひし形など任意の形状 | 精密な判定が必要 |
| **距離判定（ロジック側）** | 座標で距離計算 | キャラ同士の接触 |

---

## サッカーゲーム向け推奨構成

```
┌─────────────────────────────────────┐
│           見た目（View）             │
│  ・アイソメ風のフィールド画像        │
│  ・キャラは斜め視点の2Dスプライト    │
└─────────────────────────────────────┘
               ↑ 分離 ↓
┌─────────────────────────────────────┐
│          ロジック（Model）           │
│  ・内部は通常の2D座標で計算          │
│  ・当たり判定は円形（距離判定）      │
│  ・ボール軌道も2D座標で処理          │
└─────────────────────────────────────┘
```

### サンプルコード

```csharp
// 円形の当たり判定（距離ベース）
public bool IsColliding(Vector2 posA, Vector2 posB, float radiusA, float radiusB)
{
    float distance = Vector2.Distance(posA, posB);
    return distance < (radiusA + radiusB);
}

// ワールド座標 → 画面座標への変換（アイソメ用）
public Vector2 WorldToIso(Vector2 worldPos)
{
    float isoX = (worldPos.x - worldPos.y);
    float isoY = (worldPos.x + worldPos.y) / 2f;
    return new Vector2(isoX, isoY);
}
```

---

## まとめ

| 項目 | 推奨 |
|------|------|
| カメラ | Orthographic |
| フィールド | Isometric Tilemap or 3D平面 |
| キャラ | 2Dスプライト（斜め視点で描く） |
| 当たり判定 | 距離ベース（ロジック側で管理） |
| 座標変換 | ワールド座標 ↔ アイソメ座標 の変換関数を用意 |
